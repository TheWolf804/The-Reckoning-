#include "raylib.h"
#include "raymath.h"
#include <stdlib.h>
#include <stdbool.h>
#include <stdio.h>
#include <string.h> // for strncpy

#define MAX_ENEMIES 5
#define MAX_FIREBALLS 10
#define MAX_ENEMY_PROJECTILES 10
#define TIERS 5
#define PERKS_PER_TIER 10
#define PERKS_PER_CATEGORY (TIERS*PERKS_PER_TIER)
#define PERK_ICON_RADIUS 25
#define MAX_PLAYER_LEVEL 60  // Max level cap added

// --- Structs ---
typedef struct PlayerStats {
    int lightDamage;
    int heavyDamage;
    int fireballDamage;
    float moveSpeed;
    int maxHealth;
    float blockDamageReduction;
} PlayerStats;

typedef struct Player {
    Vector3 position;
    Vector3 velocity;
    int health;
    bool onGround;
    int jumpCount;
    bool blocking;
    bool attacking;
    int xp;
    int level;
    int perkPoints;
    int perks[5]; // legacy single-selection per category (kept for compatibility)
    PlayerStats stats;
    // new: per-style XP/levels
    int styleLevels[5];
    int styleXP[5];
    bool boughtPerks[5][PERKS_PER_CATEGORY];
} Player;

typedef struct Enemy {
    Vector3 position;
    int health;
    int maxHealth;
    bool active;
    bool attacking;
    bool staggered;
    bool retaliating; // new: enemy may retaliate when hit
    Vector3 patrolPoints[2];
    int patrolTarget;
    int damage;
    float speed;
    int level;
} Enemy;

typedef struct Fireball {
    Vector3 position;
    Vector3 velocity;
    bool active;
    int damage;
} Fireball;

typedef struct EnemyProjectile {
    Vector3 position;
    Vector3 velocity;
    bool active;
    int damage;
    bool isMagic; // magic balls home towards player
} EnemyProjectile;

typedef struct Perk {
    char* name;
    char* description;
    int levelRequired; // style level required (1,5,10,15,20)
} Perk;

typedef struct PerkCategory {
    const char* name;
    Perk perks[PERKS_PER_CATEGORY];
} PerkCategory;

// Difficulty now includes behaviour parameters
typedef struct DifficultySettings {
    const char* name;
    float enemyHealthMultiplier;
    float enemyDamageMultiplier;
    float enemySpeedMultiplier;
    float aggressiveness;   // how likely they are to chase/close gap
    float skill;            // chance to parry/block/avoid (0..1)
    float rangedChance;     // chance to use ranged attacks (0..1)
    float retaliationChance; // chance to immediately retaliate when hit (0..1)
} DifficultySettings;

// --- Regions System (ADDED) ---
typedef struct Region {
    const char* name;
    Vector3 center;
    float radius;
    Color ambientColor;
    float enemyMultiplier; // spawn/strength multiplier
    int extraHouseVariance; // randomization seed
} Region;

#define NUM_REGIONS 3

// --- Menu System ---
typedef enum MenuScreen {
    MENU_START,
    MENU_SETTINGS,
    MENU_AUDIO,
    MENU_VIDEO,
    MENU_DIFFICULTY,
    MENU_GAME,
    MENU_EXIT
} MenuScreen;

// --- Globals ---
Player player;
Enemy enemies[MAX_ENEMIES];
Fireball fireballs[MAX_FIREBALLS];
EnemyProjectile enemyProjectiles[MAX_ENEMY_PROJECTILES];
Camera3D camera;

// Regions
Region regions[NUM_REGIONS];
int currentRegionIndex = 0;       // active region index
bool regionJustChanged = false;   // to trigger randomization when switching

// --- Forward declarations for environment drawing ---
void DrawEnvironment(void);
void DrawHouse(Vector3 pos, float scale);
void DrawTree(Vector3 pos, float scale);

float deltaTime;
// Static environment placement for tutorial village (hand-placed)
static Vector3 housePositions[4] = { {3.0f, 1.0f, 3.0f}, {-4.0f, 1.0f, 5.0f}, {6.0f, 1.0f, -2.0f}, {-6.0f, 1.0f, -4.0f} };
static float houseScales[4] = {1.0f, 1.2f, 0.9f, 1.1f};
static Vector3 treePositions[8] = { {2.0f,1.0f,8.0f}, {-2.0f,1.0f,9.0f}, {5.0f,1.0f,6.0f}, {-5.0f,1.0f,6.5f}, {8.0f,1.0f,-1.0f}, {-8.0f,1.0f,-2.0f}, {0.0f,1.0f,-6.0f}, {3.0f,1.0f,-7.5f} };
static Vector3 fenceStart = {-8.0f, 0.5f, 10.0f};
static int fencePosts = 10;

bool isDead = false;
bool showPerkMenu = false;
Vector2 mousePos;
int selectedCategory = 0;
int selectedPerk = -1; // index within PERKS_PER_CATEGORY when viewing

MenuScreen currentScreen = MENU_START;
int mainMenuSelection = 0;
int settingsMenuSelection = 0;

// Audio/Video/Difficulty options
float masterVolume = 1.0f;
float musicVolume = 1.0f;
float sfxVolume = 1.0f;
bool fullscreen = false;
int screenWidth = 800;
int screenHeight = 600;
int difficulty = 2; // 0: Practise ... 7: Armagedon

DifficultySettings difficulties[8] = {
    // name, healthMult, dmgMult, speedMult, aggressiveness, skill, rangedChance, retaliationChance
    {"Practise", 0.5f, 0.5f, 0.5f, 0.4f, 0.10f, 0.10f, 0.05f},
    {"Easy",     0.8f, 0.8f, 0.8f, 0.6f, 0.20f, 0.15f, 0.10f},
    {"Normal",   1.0f, 1.0f, 1.0f, 1.0f, 0.40f, 0.35f, 0.25f},
    {"Hard",     1.2f, 1.2f, 1.1f, 1.3f, 0.55f, 0.50f, 0.40f},
    {"Insane",   1.5f, 1.5f, 1.2f, 1.6f, 0.70f, 0.65f, 0.60f},
    {"Nightmare",2.0f, 2.0f, 1.5f, 2.0f, 0.80f, 0.75f, 0.75f},
    {"DeathWish",3.0f, 3.0f, 2.0f, 3.0f, 0.90f, 0.85f, 0.85f},
    {"Armagedon",5.0f, 5.0f, 3.0f, 4.0f, 0.98f, 0.95f, 0.95f}
};

PerkCategory perkCategories[5]; // will be filled at Init

// --- Function Prototypes ---
void InitGame(void);
void SetupPerks(void);
void UpdatePlayer(float delta);
void UpdateEnemies(float delta);
void UpdateFireballs(float delta);
void SpawnFireball(void);
void DrawGame(void);
void DrawHealthBar(Vector3 position, int health, int maxHealth);
void ResetGame(void);
void UpdatePerkMenu(void);
void DrawPerkMenu(void);
void ApplyPerkEffects(void);
void ScaleEnemyStats(Enemy* e);
void LevelUpPlayer(void);
void SpawnEnemy(Enemy* e, Vector3 pos);

// Enemy projectiles
void SpawnEnemyProjectile(Enemy* e, bool isMagic);
void UpdateEnemyProjectiles(float delta);

// --- Menu Functions ---
void UpdateMainMenu(void);
void DrawMainMenu(void);
void UpdateSettingsMenu(void);
void DrawSettingsMenu(void);
void UpdateAudioMenu(void);
void DrawAudioMenu(void);
void UpdateVideoMenu(void);
void DrawVideoMenu(void);
void UpdateDifficultyMenu(void);
void DrawDifficultyMenu(void);

// --- Helpers ---
void AddStyleXP(int styleIndex, int xpGain);

// --- Regions functions (ADDED) ---
void InitRegions(void);
void RandomizeRegionContent(int regionIndex);
void UpdateRegions(float delta);
int FindRegionByPosition(Vector3 pos);

// --- Main ---
int main(void)
{
    InitWindow(screenWidth, screenHeight, "The Reckoning - 3D Raylib RPG with Menu");
    InitAudioDevice();
    InitGame();
    SetTargetFPS(60);

    while (!WindowShouldClose())
    {
        deltaTime = GetFrameTime();
        mousePos = GetMousePosition();

        switch(currentScreen) {
            case MENU_START: UpdateMainMenu(); break;
            case MENU_SETTINGS: UpdateSettingsMenu(); break;
            case MENU_AUDIO: UpdateAudioMenu(); break;
            case MENU_VIDEO: UpdateVideoMenu(); break;
            case MENU_DIFFICULTY: UpdateDifficultyMenu(); break;
            case MENU_GAME:
                if (IsKeyPressed(KEY_Z)) showPerkMenu = !showPerkMenu;

                // Act progression unlock key (L) - unlock Act1 regions
                if (IsKeyPressed(KEY_L)) {
                    if (gameAct < 1) gameAct = 1;
                    UnlockAct1Regions();
                }
                // Fast travel toggle (T)
                if (IsKeyPressed(KEY_T)) {
                    fastTravelMenu = !fastTravelMenu;
                }
                if (!isDead && !showPerkMenu) {
                    UpdatePlayer(deltaTime);
                    UpdateEnemies(deltaTime);
                    UpdateFireballs(deltaTime);
                    UpdateEnemyProjectiles(deltaTime);
                    UpdateRegions(deltaTime); // <-- integrated regions update
                }
                else if (showPerkMenu) UpdatePerkMenu();
                else if (IsKeyPressed(KEY_SPACE)) ResetGame();
                break;
            case MENU_EXIT:
                CloseAudioDevice();
                CloseWindow();
                return 0;
        }

        BeginDrawing();
        ClearBackground(RAYWHITE);

        switch(currentScreen) {
            case MENU_START: DrawMainMenu(); break;
            case MENU_SETTINGS: DrawSettingsMenu(); break;
            case MENU_AUDIO: DrawAudioMenu(); break;
            case MENU_VIDEO: DrawVideoMenu(); break;
            case MENU_DIFFICULTY: DrawDifficultyMenu(); break;
            case MENU_GAME:
                BeginMode3D(camera);
                DrawGame();
                EndMode3D();

                if (isDead)
                    DrawText("YOU DIED - Press SPACE to Restart", GetScreenWidth()/2 - 170, GetScreenHeight()/2, 30, RED);

                if (showPerkMenu) DrawPerkMenu();
                else {
                    // Draw minimap and fast travel menu
                    if (showMinimap) DrawMinimap();
                    if (fastTravelMenu) DrawFastTravelMenu();
                    DrawText(TextFormat("Health: %d/%d  Level: %d  XP: %d  Perk Points: %d",
                                player.health, player.stats.maxHealth, player.level, player.xp, player.perkPoints), 10, 10, 20, RED);
                    DrawText("WASD to move, SPACE to jump, SHIFT to block", 10, 40, 15, DARKGRAY);
                    DrawText("Left Click: Light attack, Right Click: Heavy attack, R: Fireball", 10, 60, 15, DARKGRAY);
                    DrawText("Press Z to open Perks Menu", 10, 80, 15, DARKGRAY);
                    DrawText("Press 1-5 to switch fighting styles", 10, 100, 15, DARKGRAY);

                    // show current region
                    DrawText(TextFormat("Region: %s", regions[currentRegionIndex].name), GetScreenWidth()-220, 10, 16, LIGHTGRAY);
                }
                break;
            default: break;
        }

        EndDrawing();
    }

    CloseAudioDevice();
    CloseWindow();
    return 0;
}

// --- Initialize game ---
void InitGame(void)
{
    player.position = (Vector3){ 0.0f, 1.0f, 0.0f };
    player.velocity = (Vector3){ 0,0,0 };
    player.health = 100;
    player.onGround = true;
    player.jumpCount = 0;
    player.blocking = false;
    player.attacking = false;
    player.xp = 0;
    player.level = 1;
    player.perkPoints = 0;
    for (int i=0;i<5;i++) player.perks[i]=-1;

    // init new style xp/levels and bought perks
    for (int s=0; s<5; s++) {
        player.styleLevels[s] = 1; // start at level 1 for each style
        player.styleXP[s] = 0;
        for (int k=0;k<PERKS_PER_CATEGORY;k++) player.boughtPerks[s][k] = false;
    }

    isDead = false;
    showPerkMenu = false;
    selectedCategory = 0;
    selectedPerk = -1;

    SetupPerks(); // fill perkCategories dynamically

    // --- Initialize Regions (ADDED) ---
    InitRegions();
    // Randomize a starting region at game start
    currentRegionIndex = GetRandomValue(0, NUM_REGIONS-1);
    RandomizeRegionContent(currentRegionIndex);
    regionJustChanged = true;

    for (int i=0;i<MAX_ENEMIES;i++) {
        SpawnEnemy(&enemies[i], (Vector3){ (float)(rand()%20-10), 1.0f, (float)(rand()%20-10) });
    }

    for (int i=0;i<MAX_FIREBALLS;i++) fireballs[i].active = false;
    for (int i=0;i<MAX_ENEMY_PROJECTILES;i++) enemyProjectiles[i].active = false;

    camera.position = (Vector3){ 0.0f, 10.0f, 10.0f };
    camera.target = player.position;
    camera.up = (Vector3){ 0,1,0 };
    camera.fovy = 45.0f;
    camera.projection = CAMERA_PERSPECTIVE;

    ApplyPerkEffects();
    InitRegions();
}

// Create perk names and descriptions programmatically for each category and tier
void SetupPerks(void)
{
    const char* styleNames[5] = {"BRAWLER","MAGE","KNIGHT","WARRIOR","LEGEND"};
    int tierReq[TIERS] = {1,5,10,15,20};

    for (int s=0;s<5;s++) {
        perkCategories[s].name = styleNames[s];
        for (int t=0;t<TIERS;t++) {
            for (int p=0;p<PERKS_PER_TIER;p++) {
                int idx = t*PERKS_PER_TIER + p;
                // allocate strings for name and description
                char* nameBuf = (char*)malloc(64);
                char* descBuf = (char*)malloc(128);
                sprintf(nameBuf, "%s T%d-P%d", styleNames[s], t+1, p+1);
                // give thematic descriptions per style
                switch(s){
                    case 0: // BRAWLER
                        sprintf(descBuf, "Brawler Tier %d ability #%d: boosts melee power and stability.", t+1, p+1);
                        break;
                    case 1: // MAGE
                        sprintf(descBuf, "Mage Tier %d ability #%d: enhances fire and arcane prowess.", t+1, p+1);
                        break;
                    case 2: // KNIGHT
                        sprintf(descBuf, "Knight Tier %d ability #%d: improves defenses and guard tactics.", t+1, p+1);
                        break;
                    case 3: // WARRIOR
                        sprintf(descBuf, "Warrior Tier %d ability #%d: increases mobility and stagger control.", t+1, p+1);
                        break;
                    default: // LEGEND
                        sprintf(descBuf, "Legend Tier %d ability #%d: legendary bonuses to stats.", t+1, p+1);
                        break;
                }
                perkCategories[s].perks[idx].name = nameBuf;
                perkCategories[s].perks[idx].description = descBuf;
                perkCategories[s].perks[idx].levelRequired = tierReq[t];
            }
        }
    }
}

// --- Regions implementation (ADDED) ---
// Initialize region definitions
void InitRegions(void)
{
    // Region 0: Plains - brighter, fewer enemies
    regions[0].name = "Plains";
    regions[0].center = (Vector3){ 0.0f, 0.0f, 6.0f };
    regions[0].radius = 20.0f;
    regions[0].ambientColor = Fade(SKYBLUE, 0.35f);
    regions[0].enemyMultiplier = 0.8f;
    regions[0].extraHouseVariance = 0;

    // Region 1: Forest - darker, more trees, more enemies
    regions[1].name = "Forest";
    regions[1].center = (Vector3){ 10.0f, 0.0f, -6.0f };
    regions[1].radius = 25.0f;
    regions[1].ambientColor = Fade(GREEN, 0.25f);
    regions[1].enemyMultiplier = 1.2f;
    regions[1].extraHouseVariance = 1;

    // Region 2: Ruins - eerie, stronger enemies
    regions[2].name = "Ruins";
    regions[2].center = (Vector3){ -14.0f, 0.0f, -10.0f };
    regions[2].radius = 18.0f;
    regions[2].ambientColor = Fade(LIGHTGRAY, 0.5f);
    regions[2].enemyMultiplier = 1.6f;
    regions[2].extraHouseVariance = 2;
}

// Randomize env & respawn enemies for a region
void RandomizeRegionContent(int regionIndex)
{
    if (regionIndex < 0 || regionIndex >= NUM_REGIONS) return;

    // Slightly randomize house/tree positions and fence for region flavor
    int seed = GetRandomValue(0,1000) + regionIndex*37;
    // Use seed to adjust houses and trees
    for (int i=0;i<4;i++) {
        float jitterX = (float)(GetRandomValue(-50,50)) / 10.0f + (regionIndex*2);
        float jitterZ = (float)(GetRandomValue(-50,50)) / 10.0f - (regionIndex*3);
        housePositions[i].x = regions[regionIndex].center.x + jitterX + (i*2 - 3);
        housePositions[i].z = regions[regionIndex].center.z + jitterZ + (i%2==0?2:-2);
        housePositions[i].y = 1.0f;
        houseScales[i] = 0.9f + (GetRandomValue(0,30)/100.0f);
    }

    for (int t=0;t<8;t++) {
        float jitterX = (float)(GetRandomValue(-80,80)) / 10.0f;
        float jitterZ = (float)(GetRandomValue(-80,80)) / 10.0f;
        treePositions[t].x = regions[regionIndex].center.x + jitterX + (t - 4);
        treePositions[t].z = regions[regionIndex].center.z + jitterZ - (t%3);
        treePositions[t].y = 1.0f;
    }

    // adjust fence start near region edge
    fenceStart.x = regions[regionIndex].center.x - 8.0f + GetRandomValue(-3,3);
    fenceStart.z = regions[regionIndex].center.z + 10.0f + GetRandomValue(-2,2);
    fencePosts = 8 + GetRandomValue(0,6);

    // Respawn / reposition enemies to be within the region with difficulty multiplier
    for (int i=0;i<MAX_ENEMIES;i++) {
        Vector3 pos;
        pos.x = regions[regionIndex].center.x + (GetRandomValue(- (int)regions[regionIndex].radius, (int)regions[regionIndex].radius));
        pos.z = regions[regionIndex].center.z + (GetRandomValue(- (int)regions[regionIndex].radius, (int)regions[regionIndex].radius));
        pos.y = 1.0f;
        SpawnEnemy(&enemies[i], pos);
        // scale enemy stats further by region multiplier
        enemies[i].maxHealth = (int)(enemies[i].maxHealth * regions[regionIndex].enemyMultiplier);
        enemies[i].health = enemies[i].maxHealth;
        enemies[i].damage = (int)(enemies[i].damage * regions[regionIndex].enemyMultiplier);
        enemies[i].speed *= (1.0f + (regions[regionIndex].enemyMultiplier - 1.0f) * 0.15f);
    }
}

// Returns index of region containing pos, or currentRegionIndex if none
int FindRegionByPosition(Vector3 pos)
{
    for (int i=0;i<NUM_REGIONS;i++) {
        float d = Vector2Distance((Vector2){pos.x,pos.z}, (Vector2){regions[i].center.x, regions[i].center.z});
        if (d <= regions[i].radius) return i;
    }
    return currentRegionIndex;
}

// Called every frame (when playing) to check region transitions and apply regional effects
void UpdateRegions(float delta)
{
    int newRegion = FindRegionByPosition(player.position);
    if (newRegion != currentRegionIndex) {
        currentRegionIndex = newRegion;
        regionJustChanged = true;
        RandomizeRegionContent(currentRegionIndex);
        // when switching regions, optionally scale or respawn some enemies
        for (int i=0;i<MAX_ENEMIES;i++){
            if (!enemies[i].active) {
                // spawn fresh enemy in region
                SpawnEnemy(&enemies[i], (Vector3){ regions[currentRegionIndex].center.x + GetRandomValue(-5,5), 1.0f, regions[currentRegionIndex].center.z + GetRandomValue(-5,5) });
            } else {
                // small buff or debuff on existing enemies on region change
                enemies[i].maxHealth = (int)(enemies[i].maxHealth * regions[currentRegionIndex].enemyMultiplier);
                enemies[i].health = fmin(enemies[i].health, enemies[i].maxHealth);
                enemies[i].damage = (int)(enemies[i].damage * regions[currentRegionIndex].enemyMultiplier);
            }
        }
    }

    // small ambient effect: adjust a subtle camera or world tint depending on region (we only store color - draw uses it)
    // regionJustChanged used to possibly trigger events; clear it after one frame
    if (regionJustChanged) regionJustChanged = false;
}

// --- Scale Enemy Stats Based on Difficulty & Player Level ---
void ScaleEnemyStats(Enemy* e)
{
    DifficultySettings diff = difficulties[difficulty];

    e->level = player.level + (rand() % 3 - 1);
    if (e->level < 1) e->level = 1;

    e->maxHealth = (int)((50 + e->level * 10) * diff.enemyHealthMultiplier);
    e->health = e->maxHealth;
    e->damage = (int)((8 + e->level * 2) * diff.enemyDamageMultiplier);
    e->speed = (2.0f + e->level * 0.05f) * diff.enemySpeedMultiplier;
}

// --- When Player Levels Up, Rescale All Active Enemies ---
void LevelUpPlayer(void)
{
    player.level++;
    player.perkPoints++;
    player.health = player.stats.maxHealth;

    for(int i=0;i<MAX_ENEMIES;i++)
        if(enemies[i].active) ScaleEnemyStats(&enemies[i]);
}

// --- Spawn Enemy ---
void SpawnEnemy(Enemy* e, Vector3 pos)
{
    e->position = pos;
    e->active = true;
    e->attacking = false;
    e->staggered = false;
    e->retaliating = false;
    e->patrolPoints[0] = e->position;
    e->patrolPoints[1] = (Vector3){ e->position.x + 5.0f, 1.0f, e->position.z + 5.0f };
    e->patrolTarget = 1;

    ScaleEnemyStats(e);
}

// --- Player ---
void UpdatePlayer(float delta)
{
    Vector3 move = {0,0,0};
    if (IsKeyDown(KEY_W)) move.z -= 1;
    if (IsKeyDown(KEY_S)) move.z += 1;
    if (IsKeyDown(KEY_A)) move.x -= 1;
    if (IsKeyDown(KEY_D)) move.x += 1;

    if (Vector3Length(move) > 0) {
        move = Vector3Normalize(move);
        player.position.x += move.x * player.stats.moveSpeed * delta;
        player.position.z += move.z * player.stats.moveSpeed * delta;
    }

    player.velocity.y -= 20.0f * delta;
    player.position.y += player.velocity.y * delta;

    if (player.position.y <= 1.0f) {
        player.position.y = 1.0f;
        player.onGround = true;
        player.jumpCount = 0;
        player.velocity.y = 0;
    }

    if (IsKeyPressed(KEY_SPACE) && (player.onGround || player.jumpCount < 2)) {
        player.velocity.y = 8.0f;
        player.onGround = false;
        player.jumpCount++;
    }

    player.blocking = IsKeyDown(KEY_LEFT_SHIFT);
    player.attacking = false;

    int lightDamage = player.stats.lightDamage;
    int heavyDamage = player.stats.heavyDamage;

    // get difficulty settings to allow enemies to parry/block/retaliate even before damage is applied
    DifficultySettings diff = difficulties[difficulty];

    if (IsMouseButtonPressed(MOUSE_LEFT_BUTTON)) {
        player.attacking = true;
        for (int i=0;i<MAX_ENEMIES;i++)
            if (enemies[i].active && Vector3Distance(player.position, enemies[i].position) < 2.5f) {
                // enemy may parry based on difficulty skill
                int parryRoll = GetRandomValue(0,99);
                if (parryRoll < (int)(diff.skill * 100.0f)) {
                    // parry successful -> reduce damage and trigger retaliation chance
                    enemies[i].health -= lightDamage/2;
                    enemies[i].retaliating = (GetRandomValue(0,99) < (int)(diff.retaliationChance*100.0f));
                    enemies[i].staggered = false;
                } else {
                    enemies[i].health -= lightDamage;
                    enemies[i].staggered = true;
                    // award style XP for hitting
                    AddStyleXP(selectedCategory, 5);
                    // higher difficulties more likely to retaliate when hit
                    if (GetRandomValue(0,99) < (int)(diff.retaliationChance*100.0f)) enemies[i].retaliating = true;
                }
            }
    }

    if (IsMouseButtonPressed(MOUSE_RIGHT_BUTTON)) {
        player.attacking = true;
        for (int i=0;i<MAX_ENEMIES;i++)
            if (enemies[i].active && Vector3Distance(player.position, enemies[i].position) < 3.5f) {
                int parryRoll = GetRandomValue(0,99);
                if (parryRoll < (int)(diff.skill * 100.0f)) {
                    enemies[i].health -= heavyDamage/2;
                    enemies[i].retaliating = (GetRandomValue(0,99) < (int)(diff.retaliationChance*100.0f));
                    enemies[i].staggered = false;
                } else {
                    enemies[i].health -= heavyDamage;
                    enemies[i].staggered = true;
                    AddStyleXP(selectedCategory, 8);
                    if (GetRandomValue(0,99) < (int)(diff.retaliationChance*100.0f)) enemies[i].retaliating = true;
                }
            }
    }

    if (IsKeyPressed(KEY_R)) SpawnFireball();

    Vector3 camTarget = player.position;
    Vector3 camPos = { player.position.x, player.position.y + 10.0f, player.position.z + 10.0f };
    camera.target = Vector3Lerp(camera.target, camTarget, 5.0f*delta);
    camera.position = Vector3Lerp(camera.position, camPos, 5.0f*delta);

    if (player.health <= 0) { player.health = 0; isDead = true; }
}

// Add XP to a style and handle level ups to max 20
void AddStyleXP(int styleIndex, int xpGain)
{
    if (styleIndex < 0 || styleIndex >= 5) return;
    if (player.styleLevels[styleIndex] >= 20) return;
    player.styleXP[styleIndex] += xpGain;
    int req = player.styleLevels[styleIndex] * 50; // arbitrary curve: 50 * current level
    while (player.styleXP[styleIndex] >= req && player.styleLevels[styleIndex] < 20) {
        player.styleXP[styleIndex] -= req;
        player.styleLevels[styleIndex]++;
        player.perkPoints++; // reward perk point on style level up
        // increase player base XP slightly as reward
        player.xp += 10;
        req = player.styleLevels[styleIndex] * 50;
    }
}

// --- Enemies ---
void UpdateEnemies(float delta)
{
    static float staggerTimers[MAX_ENEMIES] = {0};
    static float dashCooldowns[MAX_ENEMIES] = {0};
    static float shootCooldowns[MAX_ENEMIES] = {0};

    DifficultySettings diff = difficulties[difficulty];

    for (int i=0;i<MAX_ENEMIES;i++) {
        if (!enemies[i].active) continue;
        Enemy *e = &enemies[i];

        if (e->health <= 0) {
            e->active = false;
            player.xp += 20;

            while (player.xp >= player.level*100 && player.level < MAX_PLAYER_LEVEL) {
                player.xp -= player.level*100;
                LevelUpPlayer();
            }
            if (player.level >= MAX_PLAYER_LEVEL) {
                player.level = MAX_PLAYER_LEVEL;
                player.xp = 0;
            }

            continue;
        }

        // Patrol movement when not engaged
        Vector3 target = e->patrolPoints[e->patrolTarget];
        Vector3 dir = Vector3Subtract(target, e->position);
        float dist = Vector3Length(dir);
        if (dist < 0.1f) e->patrolTarget = (e->patrolTarget + 1) % 2;
        else {
            dir = Vector3Normalize(dir);
            e->position.x += dir.x * e->speed * delta * (1.0f / diff.aggressiveness); // less wandering at higher aggressiveness
            e->position.z += dir.z * e->speed * delta * (1.0f / diff.aggressiveness);
        }

        float distToPlayer = Vector3Distance(e->position, player.position);

        // Decrease cooldowns
        if (dashCooldowns[i] > 0) dashCooldowns[i] -= delta;
        if (shootCooldowns[i] > 0) shootCooldowns[i] -= delta;
        if (staggerTimers[i] > 0) staggerTimers[i] -= delta;

        // Stagger handling
        if (e->staggered) {
            // stagger duration slightly reduced by skill (higher skill means faster recovery)
            if (staggerTimers[i] <= 0) staggerTimers[i] = 1.0f * (1.0f - diff.skill*0.5f);
            if (staggerTimers[i] > 0) {
                staggerTimers[i] -= delta;
                if (staggerTimers[i] <= 0) { e->staggered=false; staggerTimers[i]=0; }
            }
        }

        // If enemy is set to retaliate, try to immediately retaliate (melee or ranged depending on distance)
        if (e->retaliating) {
            if (GetRandomValue(0,99) < (int)(diff.retaliationChance*100.0f)) {
                // immediate burst: either dash+melee if close, or fire a projectile if not
                if (distToPlayer <= 3.0f && dashCooldowns[i] <= 0) {
                    Vector3 dashDir = Vector3Normalize(Vector3Subtract(player.position, e->position));
                    e->position.x += dashDir.x * 8.0f * delta * diff.aggressiveness;
                    e->position.z += dashDir.z * 8.0f * delta * diff.aggressiveness;
                    // attempt immediate melee
                    if (Vector3Distance(e->position, player.position) < 2.0f) {
                        int damage = e->damage;
                        if (player.blocking) damage = (int)(damage * player.stats.blockDamageReduction);
                        player.health -= damage;
                    }
                    dashCooldowns[i] = 2.0f;
                } else if (shootCooldowns[i] <= 0) {
                    // fire a magic ball to retaliate (more likely magic on higher difficulties)
                    SpawnEnemyProjectile(e, GetRandomValue(0,99) < (int)(diff.skill*100.0f));
                    shootCooldowns[i] = 1.5f / diff.aggressiveness;
                }
            }
            e->retaliating = false; // clear flag whether or not retaliation executed
        }

        // Engage player if within detection range (scaled by aggressiveness)
        float detectRange = 6.0f * diff.aggressiveness;
        if (distToPlayer < detectRange && !e->staggered) {
            // Wander less and focus player
            if (distToPlayer > 2.0f && dashCooldowns[i] <= 0) {
                // chance to dash based on aggressiveness
                int dashRoll = GetRandomValue(0,99);
                if (dashRoll < (int)(diff.aggressiveness*60.0f)) {
                    Vector3 dashDir = Vector3Normalize(Vector3Subtract(player.position, e->position));
                    e->position.x += dashDir.x * 8.0f * delta * diff.aggressiveness;
                    e->position.z += dashDir.z * 8.0f * delta * diff.aggressiveness;
                    dashCooldowns[i] = 3.0f / diff.aggressiveness;
                }
            } else if (distToPlayer <= 2.0f && !e->attacking) {
                // decide whether to attack or attempt a parry/block
                int actionRoll = GetRandomValue(0,99);
                if (actionRoll < (int)(diff.skill * 50.0f)) {
                    // block/parry (functional effect): reduce incoming damage for a short duration
                    e->staggered = false;
                    // brief guard that makes them resistant to stagger
                    staggerTimers[i] = 0.5f * (1.0f - diff.skill*0.5f);
                } else {
                    // normal attack
                    e->attacking = true;
                }
            }

            // Ranged decision
            if (distToPlayer > 2.5f && shootCooldowns[i] <= 0) {
                int rangedRoll = GetRandomValue(0,99);
                if (rangedRoll < (int)(diff.rangedChance * 100.0f)) {
                    bool useMagic = (GetRandomValue(0,99) < (20 + e->level * 5));
                    // higher difficulties favor magic slightly
                    if (GetRandomValue(0,99) < (int)(diff.skill*50.0f)) useMagic = true;
                    SpawnEnemyProjectile(e, useMagic);
                    shootCooldowns[i] = fmaxf(0.5f, 2.0f / diff.aggressiveness);
                }
            }
        }

        // Perform attack if flagged
        if (e->attacking) {
            if (distToPlayer < 2.0f) {
                int damage = e->damage;
                if (player.blocking) damage = (int)(damage * player.stats.blockDamageReduction);
                player.health -= damage;
                e->attacking = false;
            } else e->attacking = false;
        }
    }
}

// --- Fireballs (Player) ---
void SpawnFireball(void)
{
    for (int i=0;i<MAX_FIREBALLS;i++) {
        if (!fireballs[i].active) {
            fireballs[i].active = true;
            fireballs[i].position = player.position;
            Vector3 forward = Vector3Normalize(Vector3Subtract(camera.target, camera.position));
            fireballs[i].velocity = Vector3Scale(forward, 10.0f);
            fireballs[i].damage = player.stats.fireballDamage;
            break;
        }
    }
}

void UpdateFireballs(float delta)
{
    DifficultySettings diff = difficulties[difficulty];

    for (int i=0;i<MAX_FIREBALLS;i++) {
        if (!fireballs[i].active) continue;
        fireballs[i].position.x += fireballs[i].velocity.x*delta;
        fireballs[i].position.y += fireballs[i].velocity.y*delta;
        fireballs[i].position.z += fireballs[i].velocity.z*delta;

        for (int j=0;j<MAX_ENEMIES;j++)
            if (enemies[j].active && Vector3Distance(fireballs[i].position,enemies[j].position)<1.5f) {
                // enemy may parry projectiles too (less likely than melee)
                int parryRoll = GetRandomValue(0,99);
                if (parryRoll < (int)(diff.skill * 50.0f)) {
                    // parried -> reduced damage and possible retaliation
                    enemies[j].health -= fireballs[i].damage/2;
                    enemies[j].retaliating = (GetRandomValue(0,99) < (int)(diff.retaliationChance*100.0f));
                    enemies[j].staggered = false;
                } else {
                    enemies[j].health -= fireballs[i].damage;
                    enemies[j].staggered = true;
                    if (GetRandomValue(0,99) < (int)(diff.retaliationChance*100.0f)) enemies[j].retaliating = true;
                }
                fireballs[i].active = false;
                break;
            }

        if (Vector3Distance(fireballs[i].position, player.position) > 30.0f)
            fireballs[i].active = false;
    }
}

// --- Enemy Projectiles (Fireballs & Magic Balls) ---
void SpawnEnemyProjectile(Enemy* e, bool isMagic)
{
    for (int i=0;i<MAX_ENEMY_PROJECTILES;i++) {
        if (!enemyProjectiles[i].active) {
            enemyProjectiles[i].active = true;
            enemyProjectiles[i].position = e->position;
            enemyProjectiles[i].damage = e->damage; // scale with enemy damage
            enemyProjectiles[i].isMagic = isMagic;

            Vector3 toPlayer = Vector3Subtract(player.position, e->position);
            Vector3 dir = Vector3Normalize(toPlayer);
            // magic balls are slightly slower but home; fireballs faster and straight
            if (isMagic) enemyProjectiles[i].velocity = Vector3Scale(dir, 6.0f);
            else enemyProjectiles[i].velocity = Vector3Scale(dir, 12.0f);
            break;
        }
    }
}

void UpdateEnemyProjectiles(float delta)
{
    for (int i=0;i<MAX_ENEMY_PROJECTILES;i++) {
        if (!enemyProjectiles[i].active) continue;

        if (enemyProjectiles[i].isMagic) {
            // simple homing behaviour: adjust velocity slightly towards player each frame
            Vector3 desired = Vector3Normalize(Vector3Subtract(player.position, enemyProjectiles[i].position));
            enemyProjectiles[i].velocity = Vector3Normalize(Vector3Add(Vector3Scale(enemyProjectiles[i].velocity, 0.9f), Vector3Scale(desired, 0.1f)));
            enemyProjectiles[i].velocity = Vector3Scale(enemyProjectiles[i].velocity, 6.0f);
        }

        enemyProjectiles[i].position.x += enemyProjectiles[i].velocity.x * delta;
        enemyProjectiles[i].position.y += enemyProjectiles[i].velocity.y * delta;
        enemyProjectiles[i].position.z += enemyProjectiles[i].velocity.z * delta;

        // Collision with player
        if (Vector3Distance(enemyProjectiles[i].position, player.position) < 1.2f) {
            int damage = enemyProjectiles[i].damage;
            if (player.blocking) damage = (int)(damage * player.stats.blockDamageReduction);
            player.health -= damage;
            enemyProjectiles[i].active = false;
            continue;
        }

        // Optional: player fireballs can collide with enemy projectiles and destroy them (deflect)
        for (int j=0;j<MAX_FIREBALLS;j++) {
            if (!fireballs[j].active) continue;
            if (Vector3Distance(enemyProjectiles[i].position, fireballs[j].position) < 0.8f) {
                // both destroyed
                enemyProjectiles[i].active = false;
                fireballs[j].active = false;
                break;
            }
        }

        // despawn if too far
        if (Vector3Distance(enemyProjectiles[i].position, player.position) > 50.0f ||
            Vector3Distance(enemyProjectiles[i].position, (Vector3){0,0,0}) > 100.0f) {
            enemyProjectiles[i].active = false;
        }
    }
}

// --- Drawing ---
void DrawGame(void)
{
    // Environment drawn via DrawEnvironment()
    DrawEnvironment();
    DrawCube(player.position,1.0f,2.0f,1.0f,BLUE);
    DrawHealthBar(player.position,player.health,player.stats.maxHealth);

    for (int i=0;i<MAX_ENEMIES;i++)
        if (enemies[i].active) {
            Color c = enemies[i].staggered? ORANGE : RED;
            DrawCube(enemies[i].position,1.0f,2.0f,1.0f,c);
            DrawHealthBar(enemies[i].position,enemies[i].health,enemies[i].maxHealth);
        }

    for (int i=0;i<MAX_FIREBALLS;i++)
        if (fireballs[i].active)
            DrawSphere(fireballs[i].position,0.3f,PURPLE);

    // draw enemy projectiles differently based on type
    for (int i=0;i<MAX_ENEMY_PROJECTILES;i++) {
        if (!enemyProjectiles[i].active) continue;
        if (enemyProjectiles[i].isMagic) DrawSphere(enemyProjectiles[i].position,0.35f,ORANGE);
        else DrawSphere(enemyProjectiles[i].position,0.25f,MAROON);
    }
}

// --- Environment drawing helpers ---

void DrawHouse(Vector3 pos, float scale)
{
    // Walls
    Vector3 wallSize = {2.0f * scale, 1.5f * scale, 2.0f * scale};
    DrawCube(pos, wallSize.x, wallSize.y, wallSize.z, BEIGE);
    // Slightly raised roof slab to read as a roof
    Vector3 roofPos = { pos.x, pos.y + wallSize.y*0.75f, pos.z };
    // Roof bigger in X and Z to look like an overhang
    DrawCube(roofPos, wallSize.x * 1.2f, 0.4f * scale, wallSize.z * 1.2f, MAROON);
    // Door
    Vector3 doorPos = { pos.x + (wallSize.x*0.5f - 0.2f), pos.y - (wallSize.y*0.25f), pos.z };
    DrawCube(doorPos, 0.4f*scale, 0.8f*scale, 0.05f*scale, BROWN);
    // Window
    Vector3 winPos = { pos.x - (wallSize.x*0.4f), pos.y, pos.z + (wallSize.z*0.45f) };
    DrawCube(winPos, 0.4f*scale, 0.4f*scale, 0.05f*scale, SKYBLUE);
}

void DrawTree(Vector3 pos, float scale)
{
    // trunk
    Vector3 trunkPos = { pos.x, pos.y - 0.5f * scale, pos.z };
    DrawCube(trunkPos, 0.3f * scale, 1.0f * scale, 0.3f * scale, BROWN);
    // foliage (three stacked spheres)
    Vector3 leafPos1 = { pos.x, pos.y + 0.2f * scale, pos.z };
    Vector3 leafPos2 = { pos.x + 0.15f * scale, pos.y + 0.5f * scale, pos.z - 0.1f * scale };
    Vector3 leafPos3 = { pos.x - 0.15f * scale, pos.y + 0.6f * scale, pos.z + 0.1f * scale };
    DrawSphere(leafPos1, 0.6f * scale, GREEN);
    DrawSphere(leafPos2, 0.5f * scale, GREEN);
    DrawSphere(leafPos3, 0.45f * scale, GREEN);
}

void DrawEnvironment(void)
{
    // Use region ambient color as a subtle overlay on the sky/ground (visual cue)
    Color ambient = regions[currentRegionIndex].ambientColor;
    // Large grass plane for tutorial/prologue area
    DrawPlane((Vector3){0,0,0}, (Vector2){200,200}, DARKGREEN);

    // Draw a simple path (lighter plane strip)
    for (int i=0;i<40;i++) {
        DrawCube((Vector3){0.0f, 0.01f, -i*1.0f + 10.0f}, 4.0f, 0.02f, 1.0f, Fade(LIGHTGRAY, 0.6f));
    }

    // Draw houses in hand-placed positions (now region-randomized)
    for (int i=0;i<4;i++) {
        Vector3 hpos = housePositions[i];
        DrawHouse(hpos, houseScales[i]);
    }

    // Draw trees
    for (int i=0;i<8;i++) {
        DrawTree(treePositions[i], 1.0f);
    }

    // Draw a simple fence along an edge of the village
    for (int i=0;i<fencePosts;i++) {
        Vector3 postPos = { fenceStart.x + i*1.6f, fenceStart.y, fenceStart.z };
        DrawCube(postPos, 0.1f, 0.8f, 0.1f, BROWN);
        // horizontal rail
        Vector3 railPos = { postPos.x + 0.3f, postPos.y + 0.25f, postPos.z };
        DrawCube(railPos, 1.4f, 0.08f, 0.08f, BROWN);
    }

    // Simple signage near spawn
    {
        Vector2 signPos = GetWorldToScreen((Vector3){-2.5f,1.8f,6.0f}, camera);
        DrawText("TUTORIAL VILLAGE", (int)signPos.x - 80, (int)signPos.y - 10, 20, YELLOW);
    }

    // subtle ambient overlay: draw a translucent rectangle top of screen tinted by region
    DrawRectangle(0,0,GetScreenWidth(),60, Fade(ambient, 0.1f));
}

void DrawHealthBar(Vector3 position,int health,int maxHealth)
{
    Vector2 screenPos = GetWorldToScreen((Vector3){position.x,position.y+2.3f,position.z},camera);
    DrawRectangle(screenPos.x-25,screenPos.y,50,7,RED);
    DrawRectangle(screenPos.x-25,screenPos.y,(float)health/maxHealth*50,7,GREEN);
}

void ResetGame(void){ InitGame(); }

// --- Perks ---
void UpdatePerkMenu(void)
{
    if (IsKeyPressed(KEY_RIGHT)) { selectedCategory=(selectedCategory+1)%5; selectedPerk=-1; }
    if (IsKeyPressed(KEY_LEFT)) { selectedCategory=(selectedCategory+4)%5; selectedPerk=-1; }

    if (IsKeyPressed(KEY_ONE)) selectedCategory=0;
    if (IsKeyPressed(KEY_TWO)) selectedCategory=1;
    if (IsKeyPressed(KEY_THREE)) selectedCategory=2;
    if (IsKeyPressed(KEY_FOUR)) selectedCategory=3;
    if (IsKeyPressed(KEY_FIVE)) selectedCategory=4;

    // grid layout: TIERS rows, PERKS_PER_TIER columns
    int startX = 120;
    int startY = 180;
    int gapX = 90;
    int gapY = 110;

    for (int t=0;t<TIERS;t++){
        for (int p=0;p<PERKS_PER_TIER;p++){
            int idx = t*PERKS_PER_TIER + p;
            Vector2 center = {(float)(startX + p*gapX), (float)(startY + t*gapY)};
            if (CheckCollisionPointCircle(mousePos, center, PERK_ICON_RADIUS)) {
                if (IsMouseButtonPressed(MOUSE_LEFT_BUTTON)) selectedPerk = idx;
            }
        }
    }

    if (selectedPerk>=0 && IsKeyPressed(KEY_ENTER) && player.perkPoints>0) {
        Perk *pr = &perkCategories[selectedCategory].perks[selectedPerk];
        int req = pr->levelRequired;
        if (player.styleLevels[selectedCategory] >= req && !player.boughtPerks[selectedCategory][selectedPerk]) {
            player.boughtPerks[selectedCategory][selectedPerk] = true;
            player.perkPoints--;
            ApplyPerkEffects();
        }
    }
}

void DrawPerkMenu(void)
{
    DrawRectangle(50,50,GetScreenWidth()-100,GetScreenHeight()-100,Fade(DARKGRAY,0.9f));
    DrawText("PERKS MENU - Press Z to close",60,60,20,YELLOW);
    DrawText(TextFormat("Player Level: %d  Perk Points: %d",player.level,player.perkPoints),60,90,18,WHITE);

    for (int i=0;i<player.perkPoints;i++) DrawCircle(100+i*20,150,6,YELLOW);
    DrawText("Perk Points",60,140,12,WHITE);

    for (int i=0;i<5;i++) {
        Color catColor = (i==selectedCategory)? GOLD : LIGHTGRAY;
        DrawText(perkCategories[i].name,60+i*150,130,22,catColor);
    }

    int startX = 120;
    int startY = 180;
    int gapX = 90;
    int gapY = 110;

    for (int t=0;t<TIERS;t++){
        // tier label
        DrawText(TextFormat("Tier %d (Req Lvl %d)", t+1, perkCategories[selectedCategory].perks[t*PERKS_PER_TIER].levelRequired), 60, startY + t*gapY - 10, 14, LIGHTGRAY);
        for (int p=0;p<PERKS_PER_TIER;p++){
            int idx = t*PERKS_PER_TIER + p;
            Vector2 center = {(float)(startX + p*gapX), (float)(startY + t*gapY)};
            Color bg = LIGHTGRAY;
            if (player.boughtPerks[selectedCategory][idx]) bg = GREEN;
            if (selectedPerk == idx) bg = GOLD;

            // locked if style level < required
            if (player.styleLevels[selectedCategory] < perkCategories[selectedCategory].perks[idx].levelRequired) bg = DARKGRAY;

            DrawCircleV(center, PERK_ICON_RADIUS, bg);
            DrawText(perkCategories[selectedCategory].perks[idx].name, center.x-40, center.y+30, 12, WHITE);

            if (selectedPerk==idx) {
                DrawRectangle(150,500,GetScreenWidth()-300,80,Fade(BLACK,0.7f));
                DrawText(perkCategories[selectedCategory].perks[idx].description,160,510,16,WHITE);
                DrawText(TextFormat("Required Style Level: %d", perkCategories[selectedCategory].perks[idx].levelRequired),160,535,12,LIGHTGRAY);
                if (player.boughtPerks[selectedCategory][idx]) DrawText("Purchased", GetScreenWidth()-260, 520, 14, GREEN);
                else if (player.styleLevels[selectedCategory] < perkCategories[selectedCategory].perks[idx].levelRequired)
                    DrawText("Locked - increase style level", GetScreenWidth()-360, 520, 14, RED);
                else DrawText("Press ENTER to purchase", GetScreenWidth()-260, 520, 14, YELLOW);
            }
        }
    }

    // show style level and xp
    DrawText(TextFormat("%s Level: %d  XP: %d/%d", perkCategories[selectedCategory].name, player.styleLevels[selectedCategory], player.styleXP[selectedCategory], player.styleLevels[selectedCategory]*50), 60, GetScreenHeight()-80, 16, WHITE);
}

// Apply all bought perks' effects. Effects are patterned so each perk has a meaningful impact.
void ApplyPerkEffects(void)
{
    // reset base stats first
    player.stats.lightDamage=10;
    player.stats.heavyDamage=25;
    player.stats.fireballDamage=40;
    player.stats.moveSpeed=5.0f;
    player.stats.maxHealth=100;
    player.stats.blockDamageReduction=0.5f;

    // preserve compatibility with legacy single-per-category selections
    switch(player.perks[0]){
        case 0: player.stats.lightDamage+=5; break;
        case 1: player.stats.heavyDamage+=10; break;
        case 2: player.stats.blockDamageReduction=0.8f; break;
    }
    if(player.perks[1]==0) player.stats.fireballDamage+=10;
    if(player.perks[2]==1) player.stats.maxHealth+=20;

    switch(player.perks[4]){
        case 0:
            player.stats.lightDamage=(int)(player.stats.lightDamage*1.15f);
            player.stats.heavyDamage=(int)(player.stats.heavyDamage*1.15f);
            player.stats.fireballDamage=(int)(player.stats.fireballDamage*1.15f);
            break;
        case 1: player.stats.moveSpeed*=1.2f; break;
        case 2: player.stats.maxHealth+=50; break;
    }

    // Now apply effects from all bought perks across categories
    for (int s=0;s<5;s++){
        for (int k=0;k<PERKS_PER_CATEGORY;k++){
            if (!player.boughtPerks[s][k]) continue;
            int tier = (k / PERKS_PER_TIER) + 1; // 1..5
            int posInTier = (k % PERKS_PER_TIER) + 1; // 1..10
            // create meaningful patterned effects depending on style
            switch(s){
                case 0: // BRAWLER - melee focused
                    player.stats.lightDamage += (int)(tier * (1 + posInTier/10.0f));
                    player.stats.heavyDamage += (int)(tier * (2 + posInTier/8.0f));
                    if (tier>=4 && posInTier%3==0) player.stats.blockDamageReduction *= 0.95f; // small improvement
                    break;
                case 1: // MAGE - fire/magic
                    player.stats.fireballDamage += (int)(tier * (3 + posInTier/5.0f));
                    if (tier>=3 && posInTier%2==0) player.stats.moveSpeed += 0.05f; // mage mobility tweaks
                    break;
                case 2: // KNIGHT - tanky
                    player.stats.maxHealth += tier * (5 + posInTier);
                    if (tier>=2 && posInTier%4==0) player.stats.blockDamageReduction *= 0.9f;
                    break;
                case 3: // WARRIOR - mobility & stagger
                    player.stats.moveSpeed += 0.05f * tier;
                    player.stats.heavyDamage += tier * 2;
                    break;
                case 4: // LEGEND - multiplies overall
                    player.stats.lightDamage = (int)(player.stats.lightDamage * (1.0f + tier*0.02f));
                    player.stats.heavyDamage = (int)(player.stats.heavyDamage * (1.0f + tier*0.02f));
                    player.stats.fireballDamage = (int)(player.stats.fireballDamage * (1.0f + tier*0.02f));
                    break;
            }
        }
    }

    if(player.health>player.stats.maxHealth) player.health=player.stats.maxHealth;
}


// --- Regions & Fast Travel implementations (INJECTED) ---
void InitRegions(void)
{
    // Clear and add starting regions (randomized placement within bounds for variety)
    regionCount = 0;
    // Tutorial / Spawn regions (3 start regions)
    regions[regionCount++] = (Region){"Meadow", (Vector3){-5.0f,0.0f,6.0f}, 6.0f, true, 0};
    regions[regionCount++] = (Region){"Riverside", (Vector3){4.0f,0.0f,8.0f}, 5.5f, true, 1};
    regions[regionCount++] = (Region){"Market", (Vector3){0.0f,0.0f,3.0f}, 4.5f, true, 2};
    // Locked Act1 regions (Forest, Ruins, Windy Halls)
    regions[regionCount++] = (Region){"Forest", (Vector3){20.0f,0.0f,0.0f}, 18.0f, false, 3};
    regions[regionCount++] = (Region){"Ruins", (Vector3){-22.0f,0.0f,-8.0f}, 14.0f, false, 4};
    regions[regionCount++] = (Region){"Windy Halls", (Vector3){8.0f,0.0f,-25.0f}, 16.0f, false, 5};
    // additional filler region
    regions[regionCount++] = (Region){"Outskirts", (Vector3){-18.0f,0.0f,18.0f}, 12.0f, true, 6};

    // minimap position (top-right)
    minimapPos = (Vector2){ GetScreenWidth() - minimapSize - 20, 20 };
}

void UnlockAct1Regions(void)
{
    for (int i=0;i<regionCount;i++) {
        if (strcmp(regions[i].name, "Forest")==0 || strcmp(regions[i].name, "Ruins")==0 || strcmp(regions[i].name, "Windy Halls")==0) {
            regions[i].unlocked = true;
        }
    }
}

// Fast travel UI & logic
void FastTravelToRegion(int id)
{
    for (int i=0;i<regionCount;i++) {
        if (regions[i].id == id && regions[i].unlocked) {
            player.position = (Vector3){ regions[i].center.x, 1.0f, regions[i].center.z };
            camera.target = player.position;
            camera.position = (Vector3){ player.position.x, player.position.y + 10.0f, player.position.z + 10.0f };
            fastTravelMenu = false;
            break;
        }
    }
}

void UpdateFastTravel(void)
{
    // simple keyboard navigation: up/down to select, enter to travel, esc to close
    if (IsKeyPressed(KEY_UP)) {
        fastTravelSelection = (fastTravelSelection - 1 + regionCount) % regionCount;
    }
    if (IsKeyPressed(KEY_DOWN)) {
        fastTravelSelection = (fastTravelSelection + 1) % regionCount;
    }
    if (IsKeyPressed(KEY_ENTER)) {
        if (regions[fastTravelSelection].unlocked) FastTravelToRegion(regions[fastTravelSelection].id);
    }
    if (IsKeyPressed(KEY_ESCAPE)) {
        fastTravelMenu = false;
    }
}

void DrawFastTravelMenu(void)
{
    DrawRectangle(120,120, GetScreenWidth()-240, GetScreenHeight()-240, Fade(BLACK, 0.8f));
    DrawText("FAST TRAVEL - Press ENTER to teleport, ESC to close", 140, 140, 18, YELLOW);
    int y = 180;
    for (int i=0;i<regionCount;i++) {
        Color col = (i==fastTravelSelection) ? GOLD : LIGHTGRAY;
        const char* lockTxt = regions[i].unlocked ? "" : " (Locked)";
        DrawText(TextFormat("%s%s", regions[i].name, lockTxt), 160, y, 18, col);
        y += 30;
    }
}

// Minimap drawing
void DrawMinimap(void)
{
    // small box at minimapPos showing player and regions (top-down)
    DrawRectangle(minimapPos.x-4, minimapPos.y-4, minimapSize+8, minimapSize+8, Fade(BLACK, 0.6f));
    DrawRectangleLines(minimapPos.x-4, minimapPos.y-4, minimapSize+8, minimapSize+8, GRAY);
    // define world mapping to minimap: map a square region around origin
    float mapWorldSize = 60.0f; // world units shown across minimap
    for (int i=0;i<regionCount;i++) {
        float rx = (regions[i].center.x / mapWorldSize) * minimapSize;
        float rz = (regions[i].center.z / mapWorldSize) * minimapSize;
        Vector2 pos = { minimapPos.x + minimapSize*0.5f + rx, minimapPos.y + minimapSize*0.5f + rz };
        Color rc = regions[i].unlocked ? GREEN : DARKGRAY;
        DrawCircleV(pos, 5, rc);
        DrawText(TextFormat("%d", regions[i].id), pos.x+6, pos.y-6, 10, WHITE);
    }
    // draw player
    float px = (player.position.x / mapWorldSize) * minimapSize;
    float pz = (player.position.z / mapWorldSize) * minimapSize;
    Vector2 ppos = { minimapPos.x + minimapSize*0.5f + px, minimapPos.y + minimapSize*0.5f + pz };
    DrawCircleV(ppos, 4, RED);
    DrawText("Minimap", minimapPos.x+6, minimapPos.y+minimapSize+6, 10, WHITE);
}

// --- Menus ---
void UpdateMainMenu(void)
{
    if (IsKeyPressed(KEY_DOWN)) mainMenuSelection = (mainMenuSelection + 1) % 3;
    if (IsKeyPressed(KEY_UP)) mainMenuSelection = (mainMenuSelection + 2) % 3;

    if (IsKeyPressed(KEY_ENTER) || IsMouseButtonPressed(MOUSE_LEFT_BUTTON)) {
        switch(mainMenuSelection) {
            case 0: currentScreen = MENU_GAME; break;
            case 1: currentScreen = MENU_SETTINGS; settingsMenuSelection=0; break;
            case 2: currentScreen = MENU_EXIT; break;
        }
    }
}

void DrawMainMenu(void)
{
    DrawText("THE RECKONING", screenWidth/2 - 150, 100, 50, GOLD);

    const char* options[3] = {"Start Game","Settings","Exit"};
    for (int i=0;i<3;i++) {
        Color col = (i==mainMenuSelection)? GOLD : LIGHTGRAY;
        DrawText(options[i], screenWidth/2 - 80, 250 + i*60, 30, col);
    }
}

void UpdateSettingsMenu(void)
{
    if (IsKeyPressed(KEY_DOWN)) settingsMenuSelection = (settingsMenuSelection + 1) % 4;
    if (IsKeyPressed(KEY_UP)) settingsMenuSelection = (settingsMenuSelection + 3) % 4;

    if (IsKeyPressed(KEY_ENTER) || IsMouseButtonPressed(MOUSE_LEFT_BUTTON)) {
        switch(settingsMenuSelection) {
            case 0: currentScreen = MENU_AUDIO; break;
            case 1: currentScreen = MENU_VIDEO; break;
            case 2: currentScreen = MENU_DIFFICULTY; break;
            case 3: currentScreen = MENU_START; break;
        }
    }
    if (IsKeyPressed(KEY_ESCAPE)) currentScreen = MENU_START;
}

void DrawSettingsMenu(void)
{
    DrawText("SETTINGS", screenWidth/2 - 80, 100, 50, GOLD);
    const char* options[4] = {"Audio","Video","Difficulty","Back"};
    for (int i=0;i<4;i++) {
        Color col = (i==settingsMenuSelection)? GOLD : LIGHTGRAY;
        DrawText(options[i], screenWidth/2 - 80, 250 + i*60, 30, col);
    }
}

void UpdateAudioMenu(void) { if (IsKeyPressed(KEY_ESCAPE)) currentScreen = MENU_SETTINGS; }
void DrawAudioMenu(void)
{
    DrawText("AUDIO SETTINGS - Press ESC to go back", 50,50,20,YELLOW);
    DrawText(TextFormat("Master Volume: %.1f",masterVolume), 100,150,20,WHITE);
    DrawText(TextFormat("Music Volume: %.1f",musicVolume), 100,200,20,WHITE);
    DrawText(TextFormat("SFX Volume: %.1f",sfxVolume), 100,250,20,WHITE);
}

void UpdateVideoMenu(void) { if (IsKeyPressed(KEY_ESCAPE)) currentScreen = MENU_SETTINGS; }
void DrawVideoMenu(void)
{
    DrawText("VIDEO SETTINGS - Press ESC to go back",50,50,20,YELLOW);
    DrawText(TextFormat("Resolution: %dx%d",screenWidth,screenHeight), 100,150,20,WHITE);
    DrawText(TextFormat("Fullscreen: %s", fullscreen?"ON":"OFF"), 100,200,20,WHITE);
}

void UpdateDifficultyMenu(void)
{
    if (IsKeyPressed(KEY_ESCAPE)) currentScreen = MENU_SETTINGS;
    if (IsKeyPressed(KEY_DOWN)) difficulty = (difficulty + 1) % 8;
    if (IsKeyPressed(KEY_UP)) difficulty = (difficulty + 7) % 8;
}
void DrawDifficultyMenu(void)
{
    DrawText("DIFFICULTY SETTINGS - Press ESC to go back",50,50,20,YELLOW);
    for(int i=0;i<8;i++){
        Color col = (i==difficulty)? GOLD : LIGHTGRAY;
        DrawText(difficulties[i].name,100,150+i*50,20,col);
    }
}
